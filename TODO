-  Нету работы с .gitignore файлом, из-за чего переменные окружения, креды и сертификаты будут храниться в репозитории в открытом виде. Переменные окружения стоит держать в секрете и конфигурировать для каждой среды (dev, stage, prod) отдельно.
-   Для работы с переменными окружениями нужно завести класс, в который парсить весь конфиг, при старте сервиса, в одном месте. Для работы с fastapi рекомендую использовать pydantic.BaseSettings класс.
- В проекте заведены, но никак не используются схемы pydantic. Мы не имеем подробного описания в swagger и лишены валидации и др преимуществ  pydantic.
- Часть методов api имеют PUT наименование, но по стандарту лучше отнести их к POST. Часть ответов сервиса имеют 200-ый статус, но по стандарту должны относиться к 404 или 400 статусам.
-  Структуру проекта можно организовать лучше. Тут нужно понять как разделить слои логики. Например, можно отдельно расположить ручки api, всю бизнес логину и запросы к БД. Причем бизнес логику лучше организовывать классами с конкретными атрибутами и методами, в таком случае мы получим легко читаемые сущности и останемся в парадигме ООП.
- При организации структуры БД  в данном случае лучше заложить каскадное удаление связанных сущностей (on_delete отношения для fk). Связанные данные в таком случае будут удаляться оптимально.
- Изображение лучше передавать в исходном бинарном виде (в body запроса или в multipart/form-data), а потом уже сохранять его на диск. После удаления задания файлы изображения также лучше удалять (связанные данные).
- Нету работы с уникальностью для имени изображения, но так как нету вообще работы с файлами изображения на диске, тут проблем пока не возникает.
- Токен JWT конфигурируется один раз при старте сервиса. Тут лучше проверять его актуальность и запрашивать его каждый раз, когда он протухает. Вообще нету работы со статусами ответа и ошибками от face_cloud. Ну рассматривается никакой сцинарий, кроме 200 статуса. faces_parse_unfold может вернуть False и сломает код. Нету аннотаций входных аргументов и возвращаемых значений.
- Для запросов в БД и к сторонним сервисам лучше использовать асинхронный код. Запросы к БД можно написать оптимальнее, если использовать JOIN и агрегатные функции PostgreSQL.
